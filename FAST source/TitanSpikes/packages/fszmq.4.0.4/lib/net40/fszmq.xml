<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>fszmq</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="P:fszmq.Context.Handle">
<summary>
 Pointer to underlying (native) ZMQ context
 
 ** Note: For internal use only. **
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:fszmq.Context">
<summary>
 Represents the container for a group of sockets in a node
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:fszmq.Message.Handle">
<summary>
 Pointer to underlying (native) ZMQ message
 
 ** Note: For internal use only. **
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:fszmq.Message">
<summary>
 Provides a memory-managed wrapper over ZMQ message operations
</summary>
</member>
<member name="">

</member>
<member name="M:fszmq.Poll.Create(System.Int16,fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a poll item in a way friendly to languages other then F#
</summary>
</member>
<member name="T:fszmq.Poll">
<summary>
 For use with the Poll module...
 
 Associates a callback with a Socket instance and one or more events, 
 such that the callback is invoked when the event(s) occurs on the Socket instance
 
 ** Note: all sockets passed to Polling.poll MUST share the same context 
 and belong to the thread calling `Polling.poll`. **
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollOut(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollIn(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollIO(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket sends or receives a message
</summary>
</member>
<member name="T:fszmq.PollingExtensions">
<summary>
 Utilities for working with Polling from languages other than F#
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.Proxy(fszmq.Socket,fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets, 
 with an third socket for supplemental data capture (e.g. logging)
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.Proxy(fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets
</summary>
</member>
<member name="T:fszmq.ProxyingExtensions">
<summary>
 Utilities for working with Polling from languages other than F#
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:fszmq.Socket.Handle">
<summary>
 Pointer to underlying (native) ZMQ socket
 
 ** Note: For internal use only. **
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:fszmq.Socket">
<summary>
 An abstraction of an asynchronous message queue, 
 with the exact queuing and message-exchange 
 semantics determined by the socket type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:fszmq.Version.Text">
<summary>
 textual representation of Verison
</summary>
</member>
<member name="">

</member>
<member name="T:fszmq.Version">
 <summary>
 A version of two possible states:
 <para>a triple of integers for the major revision, minor revision and 
 patch number</para>
 <para>or an `Unknown` indicator</para>
 </summary>
</member>
<member name="">

</member>
<member name="P:fszmq.ZMQError.ErrorNumber">
<summary>
 the ZeroMQ-defined, or OS-defined, error code reported by ZMQ
</summary>
</member>
<member name="">

</member>
<member name="T:fszmq.ZMQError">
 <summary>
 <para>Represents any error raised by the native ZMQ library.</para> 
 <para>Stores a human-readable summary in the `Message` property.</para>
 </summary> 
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:fszmq.ZMQEvent.TryBuild(System.Byte[][])">
<summary>
 Constructs a ZMQEvent option from a raw (binary) message
</summary>
</member>
<member name="M:fszmq.ZMQEvent.Build(System.Byte[][])">
<summary>
 Constructs a ZMQEvent from a raw (binary) message; 
 will raise NotAnEvent exception if message format is incorrect
</summary>
</member>
<member name="T:fszmq.ZMQEvent">
<summary>
 Encapsulates data generated by various ZMQ monitoring events
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:fszmq.ZMQEventDetails.Build(System.UInt16,System.Int32)">
<summary>
 Constructs a ZMQEventDetails instance based on a (native) ZeroMQ event and associated data
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails">
<summary>
 Provides more-granular information about a ZMQEvent
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:fszmq.C">

</member>
<member name="M:fszmq.ContextModule.Configure(fszmq.Context,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32}})">
<summary>
 Sets the given block of option values for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.SetOption(fszmq.Context,System.Int32,System.Int32)">
<summary>
 Sets the given option value for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.GetOption(fszmq.Context,System.Int32)">
<summary>
 Gets the value of the given option for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.Stream(fszmq.Context)">
 <summary>
 Creates a socket which can, asynchronously, send data to or 
 receive data from an non-ZeroMQ peer (via the `TCP` transport). 
 <para>Note: each message should begin with a peer identity. </para>
 <para>Additionally, a `ZMQ.STREAM` socket can act as client or a server. 
 When acting as a server, the socket MUST set the `ZMQ.SENDMORE` flag. 
 When acting as a client, the `ZMQ.SENDMORE` flag is ignored. 
 Sending an identity followed by an empty frame, closes the connection.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.SubscribeEx(fszmq.Context)">
 <summary>
 Behaves the same as a subscriber, except topical filtering is done
 by the publisher (before sending a message). 
 <para>Note: subscriptions are made by sending a subscription message,
 in which the first byte is 1 or 0 (subscribe or unsubscribe) 
 and the remainder of the message is the topic</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.PublishEx(fszmq.Context)">
<summary>
 Behaves the same as a publisher, except topical filtering is done
 by the publisher (before sending a message)
</summary>
</member>
<member name="M:fszmq.ContextModule.Subscribe(fszmq.Context)">
 <summary>
 Creates a subscriber to receive to data distributed by a publisher. 
 <para>Initially a `ZMQ.SUB` socket is not subscribed to any messages 
 (i.e. one, or more, subscriptions must be manually applied before 
 any messages will be received).</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Publish(fszmq.Context)">
 <summary>
 Creates a publisher used to distribute messages to subscribers. 
 <para>Note: topical filtering will be done by the subscriber</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Push(fszmq.Context)">
<summary>
 Creates a pipeline node to send messages to downstream (`ZMQ.PULL`) nodes.
</summary>
</member>
<member name="M:fszmq.ContextModule.Pull(fszmq.Context)">
<summary>
 Creates a pipeline node to receive messages from upstream (`ZMQ.PUSH`) nodes.
</summary>
</member>
<member name="M:fszmq.ContextModule.Router(fszmq.Context)">
 <summary>
 Creates an advanced socket type used for extending the request/reply 
 pattern. 
 <para>When receiving messages a `ZMQ.ROUTER` socket prepends a 
 message part containing the identity of the originating peer. </para>
 <para>When sending messages a `ZMQ.ROUTER` socket removes the first 
 part of the message and uses it to determine the identity of the recipient.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Dealer(fszmq.Context)">
 <summary>
 Creates an advanced socket type used for extending the request/reply 
 pattern. 
 <para>When a `ZMQ.DEALER` socket is connected to a `ZMQ.REP` socket,
 each message sent must consist of an empty message part, the 
 delimiter, followed by one or more body parts.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Response(fszmq.Context)">
 <summary>
 Creates a service to receive requests from and send replies to a 
 client. 
 <para>This socket type allows only an alternating sequence of 
 `Socket.recv(reply)` followed by `Socket.send(request)` calls.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Request(fszmq.Context)">
 <summary>
 Creates a client for sending requests to and receiving replies from 
 a service. 
 <para>This socket type allows only an alternating sequence of 
 `Socket.send(request)` followed by `Socket.recv(reply)` calls.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Pair(fszmq.Context)">
 <summary>
 Creates a peer connected to exactly one other peer. 
 <para>This socket type is used primarily for inter-thread 
 communication across the `inproc` transport.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Socket(fszmq.Context,System.Int32)">
<summary>
 Creates a Socket, of the given type, within the given context 
</summary>
</member>
<member name="T:fszmq.ContextModule">
<summary>
 Contains methods for working with Context instances
</summary>
</member>
<member name="M:fszmq.Curve.MakeCurveKeyPair">
<summary>
 Returns a newly generated random keypair consisting of a public key and a secret key. 
 The keys are encoded using ZeroMQ Base-85 Encoding.
</summary>
</member>
<member name="">

</member>
<member name="T:fszmq.Curve">
<summary>
 Utilities for working with the CurveZMQ security protocol
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:fszmq.Marshal">

</member>
<member name="M:fszmq.MessageModule.Recv(fszmq.Socket)">
<summary>
 Waits for (and returns) the next available Message from a socket
</summary>
</member>
<member name="M:fszmq.MessageModule.TryRecv(fszmq.Socket,System.Int32)">
<summary>
 Gets the next available frame from a socket, returning a Message option 
 where None indicates the operation should be re-attempted
</summary>
</member>
<member name="M:fszmq.MessageModule.op_PlusGreaterGreater(fszmq.Message,fszmq.Socket)">
<summary>
 Operator equivalent to Message.sendMore (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_MinusGreaterGreater(fszmq.Message,fszmq.Socket)">
<summary>
 Operator equivalent to Message.send (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_LessLessPlus(fszmq.Socket)">
<summary>
 Operator equivalent to Message.sendMore
</summary>
</member>
<member name="M:fszmq.MessageModule.op_LessLessMinus(fszmq.Socket)">
<summary>
 Operator equivalent to Message.send
</summary>
</member>
<member name="M:fszmq.MessageModule.SendMore(fszmq.Socket,fszmq.Message)">
<summary>
 Sends a frame, indicating more frames will follow, 
</summary>
</member>
<member name="M:fszmq.MessageModule.Send(fszmq.Socket,fszmq.Message)">
<summary>
 Sends a frame, indicating no more frames will follow
</summary>
</member>
<member name="M:fszmq.MessageModule.TrySend(fszmq.Message,fszmq.Socket,System.Int32)">
<summary>
 Sends a frame, with the given flags, returning true (or false) 
 if the send was successful (or should be re-tried)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:fszmq.MessageModule.Clone(fszmq.Message)">
<summary>
 Makes a new instance of the `Message` type, with an independent copy of the `source` content.
</summary>
</member>
<member name="M:fszmq.MessageModule.MoveTo(fszmq.Message,fszmq.Message)">
 <summary>
 Moves the content from one message to another message.
 <para>No actual copying of message content is performed, `target` is simply updated to reference the new content. 
 `source` becomes an empty message after calling `Message.move()`. The original content of `target`, if any, 
 shall be released. To preseve the content of source, see `Message.copy()`.</para>
 </summary>
</member>
<member name="M:fszmq.MessageModule.CopyTo(fszmq.Message,fszmq.Message)">
 <summary>
 Copies the content from one message to another message.
 <para>Avoid modifying message content after a message has been copied, as this can result in undefined behavior. 
 If what you need is an actual hard copy, see `Message.clone()`.</para>
 </summary>
</member>
<member name="M:fszmq.MessageModule.HasMore(fszmq.Message)">
<summary>
 Returns true if the given message is a frame in a multi-part message and more frames are available
</summary>
</member>
<member name="M:fszmq.MessageModule.GetSize(fszmq.Message)">
<summary>
 Returns the size (in bytes) of the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.GetData(fszmq.Message)">
<summary>
 Returns the content of the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.SetOption(fszmq.Message,System.Int32,System.Int32)">
<summary>
 Sets the given option value for the given Socket
</summary>
</member>
<member name="M:fszmq.MessageModule.GetOption(fszmq.Message,System.Int32)">
<summary>
 Gets the value of the given option for the given Message
</summary>
</member>
<member name="T:fszmq.MessageModule">
<summary>
 Contains methods for working with Message instances
</summary>
</member>
<member name="M:fszmq.PollingModule.PollForever(System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Calls Polling.poll with the given sequence of Poll items and no timeout,
 effectively causing the polling loop to block indefinitely.
</summary>
</member>
<member name="M:fszmq.PollingModule.PollNow(System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Calls Polling.poll with the given sequence of 
 Poll items and 0 microseconds timeout
</summary>
</member>
<member name="M:fszmq.PollingModule.Poll(System.Int64,System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Performs a single polling run 
 across the given sequence of Poll items, waiting up to the given timeout. 
 Returns true when one or more callbacks have been invoked, returns false otherwise.

 ** Note: All items passed to Polling.poll MUST share the same context 
 and belong to the thread calling `Polling.poll`. **
</summary>
</member>
<member name="M:fszmq.PollingModule.PollInOut(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket sends or receives messages
</summary>
</member>
<member name="M:fszmq.PollingModule.PollOut(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket sends a message
</summary>
</member>
<member name="M:fszmq.PollingModule.PollIn(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will 
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="T:fszmq.PollingModule">
<summary>
 Contains methods for working with ZMQ&apos;s polling capabilities
</summary>
</member>
<member name="M:fszmq.ProxyingModule.Proxy(fszmq.Socket,fszmq.Socket,Microsoft.FSharp.Core.FSharpOption{fszmq.Socket})">
<summary>
 creates a proxy connection passing messages between two sockets, 
 with an (optional) third socket for supplemental data capture 
</summary>
</member>
<member name="T:fszmq.ProxyingModule">
<summary>
 Contains methods for working with ZMQ&apos;s proxying capabilities
</summary>
</member>
<member name="M:fszmq.SocketModule.CreateMonitor(fszmq.Socket,System.String,System.Int32)">
<summary>
 Creates a `ZMQ.PAIR` socket, bound to the given address, which broadcasts 
 events for the given socket. These events should be consumed by another `ZMQ.PAIR` socket 
 connected to the given address (preferably on a background thread). 
</summary>
</member>
<member name="M:fszmq.SocketModule.RecvAll(fszmq.Socket)">
<summary>
 Retrieves all frames of the next available message
</summary>
</member>
<member name="M:fszmq.SocketModule.RecvMore(fszmq.Socket)">
<summary>
 Returns true if more message frames are available
</summary>
</member>
<member name="M:fszmq.SocketModule.Recv(fszmq.Socket)">
<summary>
 Waits for (and returns) the next available frame from a socket
</summary>
</member>
<member name="M:fszmq.SocketModule.TryRecv(fszmq.Socket,System.Int32,System.Int32)">
<summary>
 Gets the next available frame from a socket, returning a frame option
 where None indicates the operation should be re-attempted
</summary>
</member>
<member name="M:fszmq.SocketModule.SendAll(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Sends all frames of a given message
</summary>
</member>
<member name="M:fszmq.SocketModule.op_BarTwiddleGreater(System.Byte[],fszmq.Socket)">
<summary>
 Operator equivalent to Socket.sendMore (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.SocketModule.op_BarGreaterGreater(System.Byte[],fszmq.Socket)">
<summary>
 Operator equivalent to Socket.send (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.SocketModule.op_LessTwiddleBar(fszmq.Socket)">
<summary>
 Operator equivalent to Socket.sendMore
</summary>
</member>
<member name="M:fszmq.SocketModule.op_LessLessBar(fszmq.Socket)">
<summary>
 Operator equivalent to Socket.send
</summary>
</member>
<member name="M:fszmq.SocketModule.SendMore(fszmq.Socket,System.Byte[])">
<summary>
 Sends a frame (blocking), indicating more frames will follow, and returning the given socket
</summary>
</member>
<member name="M:fszmq.SocketModule.Send(fszmq.Socket,System.Byte[])">
<summary>
 Sends a frame (blocking), indicating no more frames will follow
</summary>
</member>
<member name="M:fszmq.SocketModule.TrySend(fszmq.Socket,System.Byte[],System.Int32)">
<summary>
 Sends a frame, with the given flags, returning true (or false) 
 if the send was successful (or should be re-tried)
</summary>
</member>
<member name="M:fszmq.SocketModule.Unsubscribe(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Removes one subscription for each of the given topics
</summary>
</member>
<member name="M:fszmq.SocketModule.Subscribe(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Adds one subscription for each of the given topics
</summary>
</member>
<member name="M:fszmq.SocketModule.Configure(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Object}})">
<summary>
 Sets the given block of option values for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.SetOption``1(fszmq.Socket,System.Int32,``0)">
<summary>
 Sets the given option value for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.GetOption``1(fszmq.Socket,System.Int32)">
<summary>
 Gets the value of the given option for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.Disconnect(fszmq.Socket,System.String)">
<summary>
 Disconnects to an endpoint from the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Connect(fszmq.Socket,System.String)">
<summary>
 Connects to an endpoint to the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Unbind(fszmq.Socket,System.String)">
<summary>
 Causes an endpoint to stop accepting
 connections at the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Bind(fszmq.Socket,System.String)">
<summary>
 Causes an endpoint to start accepting
 connections at the given address
</summary>
</member>
<member name="T:fszmq.SocketModule">
<summary>
 Contains methods for working with Socket instances
</summary>
</member>
<member name="M:fszmq.Timing.Sleep(System.Int32)">
<summary>
 sleeps the current thread for given number of seconds
</summary>
</member>
<member name="M:fszmq.Timing.ExecuteTimed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 executes given function, returning elapsed microseconds
</summary>
</member>
<member name="M:fszmq.Timing.StopWatch(System.IntPtr)">
<summary>
 stops the stopwatch; returns the number of microseconds elapsed
</summary>
</member>
<member name="">

</member>
<member name="T:fszmq.Timing">

</member>
<member name="M:fszmq.Z85.Decode(System.String)">
<summary>
 Decodes ZeroMQ Base-85 encoded string to a binary block.
 
 ** Note: the size of the string MUST be divisible be 5. **
</summary>
</member>
<member name="M:fszmq.Z85.Encode(System.Byte[])">
<summary>
 Encodes a binary block into a string using ZeroMQ Base-85 Encoding.

 ** Note: the size of the binary block MUST be divisible be 4. **
</summary>
</member>
<member name="T:fszmq.Z85">
<summary>
 Utilities for working with ZeroMQ Base-85 Encoding
</summary>
</member>
<member name="P:fszmq.ZMQ.FOREVER">
<summary>
 indicates polling should wait indefinitely 
</summary>
</member>
<member name="P:fszmq.ZMQ.NOW">
<summary>
 indicates polling should exit immediately
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLERR">
<summary>
 poll for messages on stderr (for use with file descriptors)
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLOUT">
<summary>
 poll for outbound messages
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLIN">
<summary>
 poll for inbound messages
</summary>
</member>
<member name="P:fszmq.ZMQ.NOBLOCK">
<summary>
 Deprecated. Use ZMQ.DONTWAIT
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDMORE">
<summary>
 More message frames will follow the current frame
</summary>
</member>
<member name="P:fszmq.ZMQ.DONTWAIT">
<summary>
 Queue message frame for sending (return immediately)
</summary>
</member>
<member name="P:fszmq.ZMQ.WAIT">
<summary>
 Block thread until message frame is sent
</summary>
</member>
<member name="P:fszmq.ZMQ.MORE">
<summary>
 (Int32) 1 if more message frames are available, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_BEHAVIOR">
<summary>
 Deprecated. Use ZMQ.ROUTER_MANDATORY
</summary>
</member>
<member name="P:fszmq.ZMQ.FAIL_UNROUTABLE">
<summary>
 Deprecated. Use ZMQ.ROUTER_MANDATORY
</summary>
</member>
<member name="P:fszmq.ZMQ.DELAY_ATTACH_ON_CONNECT">
<summary>
 Deprecated. Use ZMQ.IMMEDAITE
</summary>
</member>
<member name="P:fszmq.ZMQ.IPV4ONLY">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.NO_LINGER">
<summary>
 (Int32) the value needed to disable lingering on a socket&apos;s outbound queue
</summary>
</member>
<member name="P:fszmq.ZMQ.ZAP_DOMAIN">
<summary>
 (String) Sets authentication domain
</summary>
</member>
<member name="P:fszmq.ZMQ.CONFLATE">
<summary>
 (Int32) 1 to keep last message in queue (ignores high-water mark options), 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ_RELAXED">
<summary>
 (Int32) 1 to relax strict alternation between ZMQ.REQ and ZMQ.REP, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ_CORRELATE">
<summary>
 (Int32) 1 to prefix messages with explicit request ID, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.PROBE_ROUTER">
<summary>
 (Int32) 1 to automatically send an empty message on new connection, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SERVERKEY">
<summary>
 (String or Byte[]) sets the long-term server key on a client socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SECRETKEY">
<summary>
 (String or Byte[]) sets the long-term secret key on a client socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_PUBLICKEY">
<summary>
 (String or Byte[]) sets the long-term public key on a client or server socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SERVER">
<summary>
 (Int32) 1 to make socket act as server for CURVE security, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_PASSWORD">
<summary>
 (String) Sets the password for outgoing connections over TCP or IPC
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_USERNAME">
<summary>
 (String) Sets the user name for outgoing connections over TCP or IPC
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_SERVER">
<summary>
 (Int32) 1 to make socket act as server for PLAIN security, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.IPV6">
<summary>
 (Int32) 1 to enable IPv6 on the socket, 0 to restrict to only IPv4
</summary>
</member>
<member name="P:fszmq.ZMQ.XPUB_VERBOSE">
<summary>
 (Int32) 1 will resend duplicate messages
</summary>
</member>
<member name="P:fszmq.ZMQ.IMMEDIATE">
<summary>
 (Int32) 1 to limit queuing to only completed connections, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_ACCEPT_FILTER">
<summary>
 (Byte[]) TCP/IP filters
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_INTVL">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_IDLE">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_CNT">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_MANDATORY">
<summary>
 (Int32) 1 to error on unroutable messages, 0 to silently ignore
</summary>
</member>
<member name="P:fszmq.ZMQ.LAST_ENDPOINT">
<summary>
 (String) Last address bound to endpoint
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDTIMEO">
<summary>
 (Int32) Timeout period for outbound messages in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVTIMEO">
<summary>
 (Int32) Timeout period for inbound messages in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.MULTICAST_HOPS">
<summary>
 (Int32) Time-to-live for each multicast packet in network-hops
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVHWM">
<summary>
 (Int32) Maximum number of inbound queued messages
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDHWM">
<summary>
 (Int32) Maximum number of outbound queued messages
</summary>
</member>
<member name="P:fszmq.ZMQ.MAXMSGSIZE">
<summary>
 (Int64) Maximum inbound message size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.RECONNECT_IVL_MAX">
<summary>
 (Int32) Maximum reconnection interval in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.BACKLOG">
<summary>
 (Int32) Maximum number of queued peers
</summary>
</member>
<member name="P:fszmq.ZMQ.RECONNECT_IVL">
<summary>
 (Int32) Pause before reconnect in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.LINGER">
<summary>
 (Int32) Pause before shutdown in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.TYPE">
<summary>
 (Int32) Socket type
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENTS">
<summary>
 (Int32) Socket event state, see all: Polling
</summary>
</member>
<member name="P:fszmq.ZMQ.FD">
<summary>
 (IntPtr) native file descriptor
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVMORE">
<summary>
 (Int32) 1 if more message frames are available, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVBUF">
<summary>
 (Int32) Receive-message buffer size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDBUF">
<summary>
 (Int32) Send-message buffer size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.RECOVERY_IVL">
<summary>
 (Int32) Multicast recovery period in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.RATE">
<summary>
 (Int32) Multicast data rate in kilobits per second
</summary>
</member>
<member name="P:fszmq.ZMQ.UNSUBSCRIBE">
<summary>
 (Byte[]) Remove subscription filter
</summary>
</member>
<member name="P:fszmq.ZMQ.SUBSCRIBE">
<summary>
 (Byte[]) Add subscription filter
</summary>
</member>
<member name="P:fszmq.ZMQ.IDENTITY">
<summary>
 (Byte[]) Socket identifier
</summary>
</member>
<member name="P:fszmq.ZMQ.AFFINITY">
<summary>
 (UInt64) I/O thread affinity bit-mask
</summary>
</member>
<member name="P:fszmq.ZMQ.XREP">
<summary>
 Deprecated. Use ZMQ.ROUTER
</summary>
</member>
<member name="P:fszmq.ZMQ.XREQ">
<summary>
 Deprecated. Use ZMQ.DEALER
</summary>
</member>
<member name="P:fszmq.ZMQ.STREAM">
<summary>
 Exchanges raw data with a non-ZeroMQ peer via the tcp transport
</summary>
</member>
<member name="P:fszmq.ZMQ.XSUB">
<summary>
 A publisher like ZMQ.SUB, but does not automatically forward topic subscriptions
</summary>
</member>
<member name="P:fszmq.ZMQ.XPUB">
<summary>
 A publisher like ZMQ.PUB, but does not automatically receive forwarded topic subscriptions
</summary>
</member>
<member name="P:fszmq.ZMQ.PUSH">
<summary>
 Delivers messages in a round-robin fashion to across all downstream (i.e. ZMQ.PULL) nodes
</summary>
</member>
<member name="P:fszmq.ZMQ.PULL">
<summary>
 Collects messages in a fair-queued fashion from across all upstream (i.e. ZMQ.PUSH) nodes
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER">
<summary>
 Participates in asynchronous request/reply exchanges with compatible peers (i.e. ZMQ.REQ, ZMQ.DEALER, ZMQ.ROUTER)
</summary>
</member>
<member name="P:fszmq.ZMQ.DEALER">
<summary>
 Participates in asynchronous request/reply exchanges with compatible peers (i.e. ZMQ.REP, ZMQ.DEALER, ZMQ.ROUTER)
</summary>
</member>
<member name="P:fszmq.ZMQ.REP">
<summary>
 Awaits synchronous requests of a client (i.e. ZMQ.REQ, ZMQ.DEALER), makes replies
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ">
<summary>
 Makes synchronous requests of a server (i.e. ZMQ.REP, ZMQ.ROUTER), awaits replies
</summary>
</member>
<member name="P:fszmq.ZMQ.SUB">
<summary>
 A subscribe which receives topic-prefixed messages
</summary>
</member>
<member name="P:fszmq.ZMQ.PUB">
<summary>
 A publisher which broadcasts topic-prefixed messages
</summary>
</member>
<member name="P:fszmq.ZMQ.PAIR">
<summary>
 An exclusive pair of two sockets (primarily for use with inproc transport)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ALL">
<summary>
 Monitor all possible events
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_MONITOR_STOPPED">
<summary>
 Event monitoring has been disabled
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_DISCONNECTED">
<summary>
 Broken session (specific to ipc and tcp transports)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CLOSE_FAILED">
<summary>
 Connection could not be closed (only for ipc transport)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CLOSED">
<summary>
 Socket connection closed
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ACCEPT_FAILED">
<summary>
 Could not accept client connection
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ACCEPTED">
<summary>
 Connection accepted to bound interface
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_BIND_FAILED">
<summary>
 Socket could not bind to address
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_LISTENING">
<summary>
 Socket bound to address; ready to accept connections
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECT_RETRIED">
<summary>
 Asynchronous (re)connection attempt
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECT_DELAYED">
<summary>
 Synchronous connection failed; socket is being polled
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECTED">
<summary>
 Socket connection established
</summary>
</member>
<member name="">

</member>
<member name="P:fszmq.ZMQ.MAX_SOCKETS_DFLT">
<summary>
 default maximum number of sockets (1024)
</summary>
</member>
<member name="P:fszmq.ZMQ.IO_THREADS_DFLT">
<summary>
 default number of OS-level I/O threads (1)
</summary>
</member>
<member name="P:fszmq.ZMQ.MAX_SOCKETS">
<summary>
 (Int32) Set maximum number of sockets for a context
</summary>
</member>
<member name="P:fszmq.ZMQ.IO_THREADS">
<summary>
 (Int32) Set number of OS-level I/O threads
</summary>
</member>
<member name="P:fszmq.ZMQ.EAGAIN">
<summary>
 Non-blocking mode was requested and the message cannot be sent at the moment
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:fszmq.ZMQ.Version">
<summary>
 Version of the underlying (native) ZMQ library
</summary>
</member>
<member name="T:fszmq.ZMQ">
<summary>
 Contains commonly-used pre-defined ZMQ values
</summary>
</member>
</members>
</doc>
